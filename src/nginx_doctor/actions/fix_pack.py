"""Fix pack exporter: generate hardening script + nginx patch snippet."""

from __future__ import annotations

import re
from pathlib import Path

from nginx_doctor.model.finding import Finding


class FixPackAction:
    """Export fix artifacts derived from findings."""

    def generate(self, findings: list[Finding], output_dir: str | Path) -> dict[str, str]:
        out_dir = Path(output_dir)
        out_dir.mkdir(parents=True, exist_ok=True)

        script_path = out_dir / "hardening.sh"
        patch_path = out_dir / "nginx_patch.conf"

        script_content = self._build_hardening_script(findings)
        patch_content = self._build_nginx_patch(findings)

        script_path.write_text(script_content, encoding="utf-8", newline="\n")
        patch_path.write_text(patch_content, encoding="utf-8", newline="\n")
        return {"script": str(script_path.resolve()), "patch": str(patch_path.resolve())}

    def _build_hardening_script(self, findings: list[Finding]) -> str:
        lines = [
            "#!/usr/bin/env bash",
            "set -euo pipefail",
            "",
            "# Generated by nginx-doctor fix-pack",
            "# Review each command before execution.",
            "",
            "echo \"[1/6] Checking nginx syntax...\"",
            "sudo nginx -t || true",
            "",
        ]

        ids = {f.id.split("-")[0].upper() for f in findings}
        by_id = {f.id.upper(): f for f in findings}

        if any(f.id.upper().startswith("SYSTEMD") for f in findings):
            service = self._extract_failed_service(findings) or "certbot.service"
            lines.extend(
                [
                    "echo \"[2/6] Recovering failed service...\"",
                    f"sudo systemctl restart {service}",
                    f"sudo journalctl -u {service} -n 100 --no-pager",
                    "",
                ]
            )

        if "SSH" in ids or "SSH-1" in by_id:
            lines.extend(
                [
                    "echo \"[3/6] Hardening SSH password auth...\"",
                    "sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak.$(date +%Y%m%d-%H%M%S)",
                    "sudo sed -i 's/^#\\?PasswordAuthentication .*/PasswordAuthentication no/' /etc/ssh/sshd_config",
                    "sudo sshd -t",
                    "sudo systemctl reload ssh || sudo systemctl restart ssh",
                    "",
                ]
            )

        exposed_ports = self._extract_exposed_ports(findings)
        if exposed_ports:
            lines.extend(
                [
                    "echo \"[4/6] Reviewing public Docker ports...\"",
                    "sudo docker ps --format 'table {{.Names}}\\t{{.Ports}}'",
                    "# Rebind these ports to localhost where possible:",
                    *(f"#   -p 127.0.0.1:{p}:{p}" for p in exposed_ports),
                    "# Optional temporary guardrail via firewall:",
                    *(f"sudo ufw deny {p}/tcp || true" for p in exposed_ports),
                    "",
                ]
            )

        if "VULN" in ids:
            lines.extend(
                [
                    "echo \"[5/6] Reducing package patch backlog...\"",
                    "sudo apt-get update",
                    "sudo apt-get -y upgrade",
                    "",
                ]
            )

        lines.extend(
            [
                "echo \"[6/6] Apply nginx patch snippet if relevant and reload...\"",
                "sudo nginx -t",
                "sudo systemctl reload nginx",
                "",
                "echo \"Fix-pack commands completed.\"",
            ]
        )

        return "\n".join(lines) + "\n"

    def _build_nginx_patch(self, findings: list[Finding]) -> str:
        ids = {f.id.split("-")[0].upper() for f in findings}
        full_ids = {f.id.upper() for f in findings}

        sections = [
            "# nginx-doctor generated patch snippet",
            "# Include or merge this content into your server/location blocks as appropriate.",
            "",
        ]

        if {"NGX", "SEC"} & ids or any(fid.startswith("SEC-") for fid in full_ids):
            sections.extend(
                [
                    "# Security headers",
                    "add_header X-Frame-Options \"SAMEORIGIN\" always;",
                    "add_header X-Content-Type-Options \"nosniff\" always;",
                    "add_header Referrer-Policy \"strict-origin-when-cross-origin\" always;",
                    "",
                ]
            )

        has_any_ngx = any(prefix.startswith("NGX") for prefix in ids)
        if any(fid in {"NGX-2", "NGX-3"} for fid in full_ids) or has_any_ngx:
            sections.extend(
                [
                    "# Dotfile protection",
                    "location ~ /\\.(?!well-known).* {",
                    "    deny all;",
                    "    access_log off;",
                    "    log_not_found off;",
                    "}",
                    "",
                ]
            )

        if "NGX-4" in full_ids:
            sections.extend(
                [
                    "# HTTP/2 enablement example (adjust your listen block)",
                    "# listen 443 ssl http2;",
                    "",
                ]
            )

        if "NGX-1" in full_ids:
            sections.extend(
                [
                    "# CORS hardening example for WebSocket/API paths",
                    "# add_header Access-Control-Allow-Origin \"https://yourdomain.com\" always;",
                    "",
                ]
            )

        if "NGX002" in ids:
            sections.extend(
                [
                    "# Duplicate server_name warning was detected.",
                    "# Ensure each server_name is declared in exactly one intended server block.",
                    "",
                ]
            )

        return "\n".join(sections) + "\n"

    @staticmethod
    def _extract_failed_service(findings: list[Finding]) -> str | None:
        for finding in findings:
            match = re.search(r"Service '([^']+)' has failed", finding.condition)
            if match:
                return match.group(1)
        return None

    @staticmethod
    def _extract_exposed_ports(findings: list[Finding]) -> list[int]:
        ports: set[int] = set()
        for finding in findings:
            if finding.id.split("-")[0].upper() != "NGX000":
                continue
            for evidence in finding.evidence:
                for token in re.findall(r"(?::|\s)(\d{2,5})(?=\s|$|/)", evidence.excerpt):
                    port = int(token)
                    if 1 <= port <= 65535 and port not in {80, 443, 22}:
                        ports.add(port)
        return sorted(ports)
