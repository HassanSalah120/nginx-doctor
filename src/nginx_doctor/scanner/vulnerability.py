"""Vulnerability Scanner - Collects package vulnerability posture signals.

This scanner builds a best-effort CVE/advisory view from distro package tools.
It does not provide deep CVE enrichment; it extracts what the host already knows.
"""

from __future__ import annotations

import json
import re

from nginx_doctor.connector.ssh import SSHConnector
from nginx_doctor.model.server import VulnerabilityModel


CVE_RE = re.compile(r"\bCVE-\d{4}-\d{4,7}\b", re.IGNORECASE)
ADVISORY_RE = re.compile(
    r"\b(RHSA-\d{4}:\d+|USN-\d+-\d+|DSA-\d+-\d+|FEDORA-\d{4}-[a-z0-9]+|ALAS\d{4}-\d+)\b",
    re.IGNORECASE,
)


class VulnerabilityScanner:
    """Scanner for package vulnerability posture."""

    def __init__(self, ssh: SSHConnector) -> None:
        self.ssh = ssh

    def scan(self) -> VulnerabilityModel:
        """Collect vulnerability posture using available package tooling."""
        if self.ssh.run("which apt 2>/dev/null").success:
            return self._scan_apt()
        if self.ssh.run("which dnf 2>/dev/null").success:
            return self._scan_dnf()
        if self.ssh.run("which yum 2>/dev/null").success:
            return self._scan_yum()
        return VulnerabilityModel(provider="unknown")

    def _scan_apt(self) -> VulnerabilityModel:
        model = VulnerabilityModel(provider="apt")

        upgradable = self.ssh.run("apt list --upgradable 2>/dev/null")
        if upgradable.success and upgradable.stdout.strip():
            for line in upgradable.stdout.splitlines():
                clean = line.strip()
                if not clean or clean.startswith("Listing..."):
                    continue
                if "/" in clean:
                    pkg = clean.split("/", 1)[0].strip()
                    if pkg:
                        model.affected_packages.append(pkg)
                model.cve_ids.extend(CVE_RE.findall(clean))
                model.advisory_ids.extend(ADVISORY_RE.findall(clean))

        # Optional richer sources (if available on the host).
        for cmd in (
            "pro security-status --format json 2>/dev/null",
            "ubuntu-security-status --format json 2>/dev/null",
        ):
            res = self.ssh.run(cmd)
            if not res.success or not res.stdout.strip():
                continue
            try:
                data = json.loads(res.stdout)
            except json.JSONDecodeError:
                self._extract_from_text(res.stdout, model)
                continue
            self._extract_from_json(data, model)

        self._normalize(model)
        return model

    def _scan_dnf(self) -> VulnerabilityModel:
        model = VulnerabilityModel(provider="dnf")
        list_res = self.ssh.run("dnf -q updateinfo list --updates security 2>/dev/null || true")
        self._extract_from_text(list_res.stdout or "", model)

        info_res = self.ssh.run("dnf -q updateinfo info --updates security 2>/dev/null || true")
        self._extract_from_text(info_res.stdout or "", model)

        self._normalize(model)
        return model

    def _scan_yum(self) -> VulnerabilityModel:
        model = VulnerabilityModel(provider="yum")
        list_res = self.ssh.run("yum -q updateinfo list security all 2>/dev/null || true")
        self._extract_from_text(list_res.stdout or "", model)

        info_res = self.ssh.run("yum -q updateinfo info security all 2>/dev/null || true")
        self._extract_from_text(info_res.stdout or "", model)

        self._normalize(model)
        return model

    def _extract_from_json(self, data: object, model: VulnerabilityModel) -> None:
        if isinstance(data, dict):
            for k, v in data.items():
                self._extract_from_text(str(k), model)
                self._extract_from_json(v, model)
            return
        if isinstance(data, list):
            for item in data:
                self._extract_from_json(item, model)
            return
        if isinstance(data, str):
            self._extract_from_text(data, model)

    def _extract_from_text(self, text: str, model: VulnerabilityModel) -> None:
        if not text:
            return
        model.cve_ids.extend(CVE_RE.findall(text))
        model.advisory_ids.extend(ADVISORY_RE.findall(text))

        for line in text.splitlines():
            clean = line.strip()
            if not clean:
                continue
            parts = clean.split()
            if len(parts) >= 3:
                # Best effort for dnf/yum style: advisory ... package
                last = parts[-1]
                if "." in last and not last.lower().startswith("http"):
                    pkg = last.split(".")[0]
                    if pkg and pkg[0].isalnum():
                        model.affected_packages.append(pkg)

    def _normalize(self, model: VulnerabilityModel) -> None:
        model.cve_ids = sorted(set(c.upper() for c in model.cve_ids))
        model.advisory_ids = sorted(set(a.upper() for a in model.advisory_ids))
        model.affected_packages = sorted(set(model.affected_packages))
